State 0 conflicts: 4 reduce/reduce
State 3 conflicts: 1 shift/reduce, 2 reduce/reduce
State 11 conflicts: 1 shift/reduce, 2 reduce/reduce
State 24 conflicts: 2 shift/reduce
State 30 conflicts: 1 shift/reduce
State 51 conflicts: 1 shift/reduce
State 60 conflicts: 10 shift/reduce
State 62 conflicts: 10 reduce/reduce
State 63 conflicts: 10 reduce/reduce


Grammar

    0 $accept: PROGRAM $end

    1 PROGRAM: DEFINED_V GLOB_VARS DEFINED_F FUNCS MAIN_FUNC

    2 DEFINED_V: DEF_VARS
    3          | %empty

    4 DEF_VARS: DEF_VAR end DEF_VARS
    5         | %empty

    6 DEF_VAR: def var_name EXP

    7 GLOB_VARS: VARS
    8          | %empty

    9 VARS: VAR end VARS
   10     | %empty

   11 VAR: DECLARE
   12    | REASSIGN

   13 DECLARE: TYPE var_name ASSIGN

   14 ASSIGN: EXP
   15       | %empty

   16 REASSIGN: var_name EXP

   17 EXP: string_var
   18    | int_var
   19    | var_name
   20    | open_par EXP close_par
   21    | OP
   22    | EVALUATE

   23 OP: EXP add EXP
   24   | EXP sub EXP
   25   | EXP mult EXP
   26   | EXP divi EXP

   27 TYPE: t_string
   28     | t_int

   29 EVALUATE: EXP COMP EXP
   30         | EVALUATE and EVALUATE
   31         | EVALUATE or EVALUATE

   32 COMP: equal
   33     | neq
   34     | bigger
   35     | smaller
   36     | beq
   37     | seq

   38 DEFINED_F: DEF_FUNCS
   39          | %empty

   40 DEF_FUNCS: DEF_FUNC end DEF_FUNCS
   41          | %empty

   42 DEF_FUNC: var_name TYPE open_par ARGS close_par

   43 ARGS: ARG comma ARGS
   44     | %empty

   45 ARG: TYPE var_name

   46 FUNCS: FUNC FUNCS
   47      | %empty

   48 FUNC: var_name TYPE open_par ARGS close_par open_func BODY end_func

   49 BODY: LINE end BODY
   50     | BLOCK BODY
   51     | %empty

   52 LINE: REASSIGN
   53     | DECLARE
   54     | INC
   55     | DEC
   56     | PRINT
   57     | SCAN
   58     | RET

   59 INC: var_name increase

   60 DEC: var_name decrease

   61 PRINT: t_printf open_par EXP close_par

   62 SCAN: t_scanf open_par var_name close_par

   63 RET: t_ret EXP

   64 BLOCK: IFBLOCK
   65      | WHILEBLOCK

   66 IFBLOCK: open_if EVALUATE end BODY close_if

   67 WHILEBLOCK: open_while EVALUATE end BODY close_while

   68 MAIN_FUNC: main_func TYPE open_par ARGS close_par open_func BODY end_func


Terminals, with rules where they appear

$end (0) 0
error (256)
add (258) 23
sub (259) 24
mult (260) 25
divi (261) 26
t_string (262) 27
t_int (263) 28
def (264) 6
t_scanf (265) 62
t_printf (266) 61
increase (267) 59
decrease (268) 60
open_while (269) 67
close_while (270) 67
open_if (271) 66
close_if (272) 66
and (273) 30
or (274) 31
equal (275) 32
neq (276) 33
seq (277) 37
smaller (278) 35
beq (279) 36
bigger (280) 34
main_func (281) 68
comma (282) 43
close_par (283) 20 42 48 61 62 68
open_par (284) 20 42 48 61 62 68
open_func (285) 48 68
t_ret (286) 63
end_func (287) 48 68
end (288) 4 9 40 49 66 67
int_var (289) 18
string_var (290) 17
var_name (291) 6 13 16 19 42 45 48 59 60 62


Nonterminals, with rules where they appear

$accept (37)
    on left: 0
PROGRAM (38)
    on left: 1, on right: 0
DEFINED_V (39)
    on left: 2 3, on right: 1
DEF_VARS (40)
    on left: 4 5, on right: 2 4
DEF_VAR (41)
    on left: 6, on right: 4
GLOB_VARS (42)
    on left: 7 8, on right: 1
VARS (43)
    on left: 9 10, on right: 7 9
VAR (44)
    on left: 11 12, on right: 9
DECLARE (45)
    on left: 13, on right: 11 53
ASSIGN (46)
    on left: 14 15, on right: 13
REASSIGN (47)
    on left: 16, on right: 12 52
EXP (48)
    on left: 17 18 19 20 21 22, on right: 6 14 16 20 23 24 25 26 29
    61 63
OP (49)
    on left: 23 24 25 26, on right: 21
TYPE (50)
    on left: 27 28, on right: 13 42 45 48 68
EVALUATE (51)
    on left: 29 30 31, on right: 22 30 31 66 67
COMP (52)
    on left: 32 33 34 35 36 37, on right: 29
DEFINED_F (53)
    on left: 38 39, on right: 1
DEF_FUNCS (54)
    on left: 40 41, on right: 38 40
DEF_FUNC (55)
    on left: 42, on right: 40
ARGS (56)
    on left: 43 44, on right: 42 43 48 68
ARG (57)
    on left: 45, on right: 43
FUNCS (58)
    on left: 46 47, on right: 1 46
FUNC (59)
    on left: 48, on right: 46
BODY (60)
    on left: 49 50 51, on right: 48 49 50 66 67 68
LINE (61)
    on left: 52 53 54 55 56 57 58, on right: 49
INC (62)
    on left: 59, on right: 54
DEC (63)
    on left: 60, on right: 55
PRINT (64)
    on left: 61, on right: 56
SCAN (65)
    on left: 62, on right: 57
RET (66)
    on left: 63, on right: 58
BLOCK (67)
    on left: 64 65, on right: 50
IFBLOCK (68)
    on left: 66, on right: 64
WHILEBLOCK (69)
    on left: 67, on right: 65
MAIN_FUNC (70)
    on left: 68, on right: 1


State 0

    0 $accept: . PROGRAM $end

    def  shift, and go to state 1

    t_string   reduce using rule 3 (DEFINED_V)
    t_string   [reduce using rule 5 (DEF_VARS)]
    t_int      reduce using rule 3 (DEFINED_V)
    t_int      [reduce using rule 5 (DEF_VARS)]
    main_func  reduce using rule 3 (DEFINED_V)
    main_func  [reduce using rule 5 (DEF_VARS)]
    var_name   reduce using rule 3 (DEFINED_V)
    var_name   [reduce using rule 5 (DEF_VARS)]
    $default   reduce using rule 3 (DEFINED_V)

    PROGRAM    go to state 2
    DEFINED_V  go to state 3
    DEF_VARS   go to state 4
    DEF_VAR    go to state 5


State 1

    6 DEF_VAR: def . var_name EXP

    var_name  shift, and go to state 6


State 2

    0 $accept: PROGRAM . $end

    $end  shift, and go to state 7


State 3

    1 PROGRAM: DEFINED_V . GLOB_VARS DEFINED_F FUNCS MAIN_FUNC

    t_string  shift, and go to state 8
    t_int     shift, and go to state 9
    var_name  shift, and go to state 10

    main_func  reduce using rule 8 (GLOB_VARS)
    main_func  [reduce using rule 10 (VARS)]
    var_name   [reduce using rule 8 (GLOB_VARS)]
    var_name   [reduce using rule 10 (VARS)]
    $default   reduce using rule 8 (GLOB_VARS)

    GLOB_VARS  go to state 11
    VARS       go to state 12
    VAR        go to state 13
    DECLARE    go to state 14
    REASSIGN   go to state 15
    TYPE       go to state 16


State 4

    2 DEFINED_V: DEF_VARS .

    $default  reduce using rule 2 (DEFINED_V)


State 5

    4 DEF_VARS: DEF_VAR . end DEF_VARS

    end  shift, and go to state 17


State 6

    6 DEF_VAR: def var_name . EXP

    open_par    shift, and go to state 18
    int_var     shift, and go to state 19
    string_var  shift, and go to state 20
    var_name    shift, and go to state 21

    EXP       go to state 22
    OP        go to state 23
    EVALUATE  go to state 24


State 7

    0 $accept: PROGRAM $end .

    $default  accept


State 8

   27 TYPE: t_string .

    $default  reduce using rule 27 (TYPE)


State 9

   28 TYPE: t_int .

    $default  reduce using rule 28 (TYPE)


State 10

   16 REASSIGN: var_name . EXP

    open_par    shift, and go to state 18
    int_var     shift, and go to state 19
    string_var  shift, and go to state 20
    var_name    shift, and go to state 21

    EXP       go to state 25
    OP        go to state 23
    EVALUATE  go to state 24


State 11

    1 PROGRAM: DEFINED_V GLOB_VARS . DEFINED_F FUNCS MAIN_FUNC

    var_name  shift, and go to state 26

    main_func  reduce using rule 39 (DEFINED_F)
    main_func  [reduce using rule 41 (DEF_FUNCS)]
    var_name   [reduce using rule 39 (DEFINED_F)]
    var_name   [reduce using rule 41 (DEF_FUNCS)]
    $default   reduce using rule 39 (DEFINED_F)

    DEFINED_F  go to state 27
    DEF_FUNCS  go to state 28
    DEF_FUNC   go to state 29


State 12

    7 GLOB_VARS: VARS .

    $default  reduce using rule 7 (GLOB_VARS)


State 13

    9 VARS: VAR . end VARS

    end  shift, and go to state 30


State 14

   11 VAR: DECLARE .

    $default  reduce using rule 11 (VAR)


State 15

   12 VAR: REASSIGN .

    $default  reduce using rule 12 (VAR)


State 16

   13 DECLARE: TYPE . var_name ASSIGN

    var_name  shift, and go to state 31


State 17

    4 DEF_VARS: DEF_VAR end . DEF_VARS

    def  shift, and go to state 1

    $default  reduce using rule 5 (DEF_VARS)

    DEF_VARS  go to state 32
    DEF_VAR   go to state 5


State 18

   20 EXP: open_par . EXP close_par

    open_par    shift, and go to state 18
    int_var     shift, and go to state 19
    string_var  shift, and go to state 20
    var_name    shift, and go to state 21

    EXP       go to state 33
    OP        go to state 23
    EVALUATE  go to state 24


State 19

   18 EXP: int_var .

    $default  reduce using rule 18 (EXP)


State 20

   17 EXP: string_var .

    $default  reduce using rule 17 (EXP)


State 21

   19 EXP: var_name .

    $default  reduce using rule 19 (EXP)


State 22

    6 DEF_VAR: def var_name EXP .
   23 OP: EXP . add EXP
   24   | EXP . sub EXP
   25   | EXP . mult EXP
   26   | EXP . divi EXP
   29 EVALUATE: EXP . COMP EXP

    add      shift, and go to state 34
    sub      shift, and go to state 35
    mult     shift, and go to state 36
    divi     shift, and go to state 37
    equal    shift, and go to state 38
    neq      shift, and go to state 39
    seq      shift, and go to state 40
    smaller  shift, and go to state 41
    beq      shift, and go to state 42
    bigger   shift, and go to state 43

    $default  reduce using rule 6 (DEF_VAR)

    COMP  go to state 44


State 23

   21 EXP: OP .

    $default  reduce using rule 21 (EXP)


State 24

   22 EXP: EVALUATE .
   30 EVALUATE: EVALUATE . and EVALUATE
   31         | EVALUATE . or EVALUATE

    and  shift, and go to state 45
    or   shift, and go to state 46

    and       [reduce using rule 22 (EXP)]
    or        [reduce using rule 22 (EXP)]
    $default  reduce using rule 22 (EXP)


State 25

   16 REASSIGN: var_name EXP .
   23 OP: EXP . add EXP
   24   | EXP . sub EXP
   25   | EXP . mult EXP
   26   | EXP . divi EXP
   29 EVALUATE: EXP . COMP EXP

    add      shift, and go to state 34
    sub      shift, and go to state 35
    mult     shift, and go to state 36
    divi     shift, and go to state 37
    equal    shift, and go to state 38
    neq      shift, and go to state 39
    seq      shift, and go to state 40
    smaller  shift, and go to state 41
    beq      shift, and go to state 42
    bigger   shift, and go to state 43

    $default  reduce using rule 16 (REASSIGN)

    COMP  go to state 44


State 26

   42 DEF_FUNC: var_name . TYPE open_par ARGS close_par

    t_string  shift, and go to state 8
    t_int     shift, and go to state 9

    TYPE  go to state 47


State 27

    1 PROGRAM: DEFINED_V GLOB_VARS DEFINED_F . FUNCS MAIN_FUNC

    var_name  shift, and go to state 48

    $default  reduce using rule 47 (FUNCS)

    FUNCS  go to state 49
    FUNC   go to state 50


State 28

   38 DEFINED_F: DEF_FUNCS .

    $default  reduce using rule 38 (DEFINED_F)


State 29

   40 DEF_FUNCS: DEF_FUNC . end DEF_FUNCS

    end  shift, and go to state 51


State 30

    9 VARS: VAR end . VARS

    t_string  shift, and go to state 8
    t_int     shift, and go to state 9
    var_name  shift, and go to state 10

    var_name  [reduce using rule 10 (VARS)]
    $default  reduce using rule 10 (VARS)

    VARS      go to state 52
    VAR       go to state 13
    DECLARE   go to state 14
    REASSIGN  go to state 15
    TYPE      go to state 16


State 31

   13 DECLARE: TYPE var_name . ASSIGN

    open_par    shift, and go to state 18
    int_var     shift, and go to state 19
    string_var  shift, and go to state 20
    var_name    shift, and go to state 21

    $default  reduce using rule 15 (ASSIGN)

    ASSIGN    go to state 53
    EXP       go to state 54
    OP        go to state 23
    EVALUATE  go to state 24


State 32

    4 DEF_VARS: DEF_VAR end DEF_VARS .

    $default  reduce using rule 4 (DEF_VARS)


State 33

   20 EXP: open_par EXP . close_par
   23 OP: EXP . add EXP
   24   | EXP . sub EXP
   25   | EXP . mult EXP
   26   | EXP . divi EXP
   29 EVALUATE: EXP . COMP EXP

    add        shift, and go to state 34
    sub        shift, and go to state 35
    mult       shift, and go to state 36
    divi       shift, and go to state 37
    equal      shift, and go to state 38
    neq        shift, and go to state 39
    seq        shift, and go to state 40
    smaller    shift, and go to state 41
    beq        shift, and go to state 42
    bigger     shift, and go to state 43
    close_par  shift, and go to state 55

    COMP  go to state 44


State 34

   23 OP: EXP add . EXP

    open_par    shift, and go to state 18
    int_var     shift, and go to state 19
    string_var  shift, and go to state 20
    var_name    shift, and go to state 21

    EXP       go to state 56
    OP        go to state 23
    EVALUATE  go to state 24


State 35

   24 OP: EXP sub . EXP

    open_par    shift, and go to state 18
    int_var     shift, and go to state 19
    string_var  shift, and go to state 20
    var_name    shift, and go to state 21

    EXP       go to state 57
    OP        go to state 23
    EVALUATE  go to state 24


State 36

   25 OP: EXP mult . EXP

    open_par    shift, and go to state 18
    int_var     shift, and go to state 19
    string_var  shift, and go to state 20
    var_name    shift, and go to state 21

    EXP       go to state 58
    OP        go to state 23
    EVALUATE  go to state 24


State 37

   26 OP: EXP divi . EXP

    open_par    shift, and go to state 18
    int_var     shift, and go to state 19
    string_var  shift, and go to state 20
    var_name    shift, and go to state 21

    EXP       go to state 59
    OP        go to state 23
    EVALUATE  go to state 24


State 38

   32 COMP: equal .

    $default  reduce using rule 32 (COMP)


State 39

   33 COMP: neq .

    $default  reduce using rule 33 (COMP)


State 40

   37 COMP: seq .

    $default  reduce using rule 37 (COMP)


State 41

   35 COMP: smaller .

    $default  reduce using rule 35 (COMP)


State 42

   36 COMP: beq .

    $default  reduce using rule 36 (COMP)


State 43

   34 COMP: bigger .

    $default  reduce using rule 34 (COMP)


State 44

   29 EVALUATE: EXP COMP . EXP

    open_par    shift, and go to state 18
    int_var     shift, and go to state 19
    string_var  shift, and go to state 20
    var_name    shift, and go to state 21

    EXP       go to state 60
    OP        go to state 23
    EVALUATE  go to state 24


State 45

   30 EVALUATE: EVALUATE and . EVALUATE

    open_par    shift, and go to state 18
    int_var     shift, and go to state 19
    string_var  shift, and go to state 20
    var_name    shift, and go to state 21

    EXP       go to state 61
    OP        go to state 23
    EVALUATE  go to state 62


State 46

   31 EVALUATE: EVALUATE or . EVALUATE

    open_par    shift, and go to state 18
    int_var     shift, and go to state 19
    string_var  shift, and go to state 20
    var_name    shift, and go to state 21

    EXP       go to state 61
    OP        go to state 23
    EVALUATE  go to state 63


State 47

   42 DEF_FUNC: var_name TYPE . open_par ARGS close_par

    open_par  shift, and go to state 64


State 48

   48 FUNC: var_name . TYPE open_par ARGS close_par open_func BODY end_func

    t_string  shift, and go to state 8
    t_int     shift, and go to state 9

    TYPE  go to state 65


State 49

    1 PROGRAM: DEFINED_V GLOB_VARS DEFINED_F FUNCS . MAIN_FUNC

    main_func  shift, and go to state 66

    MAIN_FUNC  go to state 67


State 50

   46 FUNCS: FUNC . FUNCS

    var_name  shift, and go to state 48

    $default  reduce using rule 47 (FUNCS)

    FUNCS  go to state 68
    FUNC   go to state 50


State 51

   40 DEF_FUNCS: DEF_FUNC end . DEF_FUNCS

    var_name  shift, and go to state 26

    var_name  [reduce using rule 41 (DEF_FUNCS)]
    $default  reduce using rule 41 (DEF_FUNCS)

    DEF_FUNCS  go to state 69
    DEF_FUNC   go to state 29


State 52

    9 VARS: VAR end VARS .

    $default  reduce using rule 9 (VARS)


State 53

   13 DECLARE: TYPE var_name ASSIGN .

    $default  reduce using rule 13 (DECLARE)


State 54

   14 ASSIGN: EXP .
   23 OP: EXP . add EXP
   24   | EXP . sub EXP
   25   | EXP . mult EXP
   26   | EXP . divi EXP
   29 EVALUATE: EXP . COMP EXP

    add      shift, and go to state 34
    sub      shift, and go to state 35
    mult     shift, and go to state 36
    divi     shift, and go to state 37
    equal    shift, and go to state 38
    neq      shift, and go to state 39
    seq      shift, and go to state 40
    smaller  shift, and go to state 41
    beq      shift, and go to state 42
    bigger   shift, and go to state 43

    $default  reduce using rule 14 (ASSIGN)

    COMP  go to state 44


State 55

   20 EXP: open_par EXP close_par .

    $default  reduce using rule 20 (EXP)


State 56

   23 OP: EXP . add EXP
   23   | EXP add EXP .
   24   | EXP . sub EXP
   25   | EXP . mult EXP
   26   | EXP . divi EXP
   29 EVALUATE: EXP . COMP EXP

    mult     shift, and go to state 36
    divi     shift, and go to state 37
    equal    shift, and go to state 38
    neq      shift, and go to state 39
    seq      shift, and go to state 40
    smaller  shift, and go to state 41
    beq      shift, and go to state 42
    bigger   shift, and go to state 43

    $default  reduce using rule 23 (OP)

    COMP  go to state 44


State 57

   23 OP: EXP . add EXP
   24   | EXP . sub EXP
   24   | EXP sub EXP .
   25   | EXP . mult EXP
   26   | EXP . divi EXP
   29 EVALUATE: EXP . COMP EXP

    mult     shift, and go to state 36
    divi     shift, and go to state 37
    equal    shift, and go to state 38
    neq      shift, and go to state 39
    seq      shift, and go to state 40
    smaller  shift, and go to state 41
    beq      shift, and go to state 42
    bigger   shift, and go to state 43

    $default  reduce using rule 24 (OP)

    COMP  go to state 44


State 58

   23 OP: EXP . add EXP
   24   | EXP . sub EXP
   25   | EXP . mult EXP
   25   | EXP mult EXP .
   26   | EXP . divi EXP
   29 EVALUATE: EXP . COMP EXP

    equal    shift, and go to state 38
    neq      shift, and go to state 39
    seq      shift, and go to state 40
    smaller  shift, and go to state 41
    beq      shift, and go to state 42
    bigger   shift, and go to state 43

    $default  reduce using rule 25 (OP)

    COMP  go to state 44


State 59

   23 OP: EXP . add EXP
   24   | EXP . sub EXP
   25   | EXP . mult EXP
   26   | EXP . divi EXP
   26   | EXP divi EXP .
   29 EVALUATE: EXP . COMP EXP

    equal    shift, and go to state 38
    neq      shift, and go to state 39
    seq      shift, and go to state 40
    smaller  shift, and go to state 41
    beq      shift, and go to state 42
    bigger   shift, and go to state 43

    $default  reduce using rule 26 (OP)

    COMP  go to state 44


State 60

   23 OP: EXP . add EXP
   24   | EXP . sub EXP
   25   | EXP . mult EXP
   26   | EXP . divi EXP
   29 EVALUATE: EXP . COMP EXP
   29         | EXP COMP EXP .

    add      shift, and go to state 34
    sub      shift, and go to state 35
    mult     shift, and go to state 36
    divi     shift, and go to state 37
    equal    shift, and go to state 38
    neq      shift, and go to state 39
    seq      shift, and go to state 40
    smaller  shift, and go to state 41
    beq      shift, and go to state 42
    bigger   shift, and go to state 43

    add       [reduce using rule 29 (EVALUATE)]
    sub       [reduce using rule 29 (EVALUATE)]
    mult      [reduce using rule 29 (EVALUATE)]
    divi      [reduce using rule 29 (EVALUATE)]
    equal     [reduce using rule 29 (EVALUATE)]
    neq       [reduce using rule 29 (EVALUATE)]
    seq       [reduce using rule 29 (EVALUATE)]
    smaller   [reduce using rule 29 (EVALUATE)]
    beq       [reduce using rule 29 (EVALUATE)]
    bigger    [reduce using rule 29 (EVALUATE)]
    $default  reduce using rule 29 (EVALUATE)

    COMP  go to state 44


State 61

   23 OP: EXP . add EXP
   24   | EXP . sub EXP
   25   | EXP . mult EXP
   26   | EXP . divi EXP
   29 EVALUATE: EXP . COMP EXP

    add      shift, and go to state 34
    sub      shift, and go to state 35
    mult     shift, and go to state 36
    divi     shift, and go to state 37
    equal    shift, and go to state 38
    neq      shift, and go to state 39
    seq      shift, and go to state 40
    smaller  shift, and go to state 41
    beq      shift, and go to state 42
    bigger   shift, and go to state 43

    COMP  go to state 44


State 62

   22 EXP: EVALUATE .
   30 EVALUATE: EVALUATE . and EVALUATE
   30         | EVALUATE and EVALUATE .
   31         | EVALUATE . or EVALUATE

    or  shift, and go to state 46

    add        reduce using rule 22 (EXP)
    add        [reduce using rule 30 (EVALUATE)]
    sub        reduce using rule 22 (EXP)
    sub        [reduce using rule 30 (EVALUATE)]
    mult       reduce using rule 22 (EXP)
    mult       [reduce using rule 30 (EVALUATE)]
    divi       reduce using rule 22 (EXP)
    divi       [reduce using rule 30 (EVALUATE)]
    and        reduce using rule 30 (EVALUATE)
    equal      reduce using rule 22 (EXP)
    equal      [reduce using rule 30 (EVALUATE)]
    neq        reduce using rule 22 (EXP)
    neq        [reduce using rule 30 (EVALUATE)]
    seq        reduce using rule 22 (EXP)
    seq        [reduce using rule 30 (EVALUATE)]
    smaller    reduce using rule 22 (EXP)
    smaller    [reduce using rule 30 (EVALUATE)]
    beq        reduce using rule 22 (EXP)
    beq        [reduce using rule 30 (EVALUATE)]
    bigger     reduce using rule 22 (EXP)
    bigger     [reduce using rule 30 (EVALUATE)]
    close_par  reduce using rule 30 (EVALUATE)
    end        reduce using rule 30 (EVALUATE)
    $default   reduce using rule 22 (EXP)


State 63

   22 EXP: EVALUATE .
   30 EVALUATE: EVALUATE . and EVALUATE
   31         | EVALUATE . or EVALUATE
   31         | EVALUATE or EVALUATE .

    add        reduce using rule 22 (EXP)
    add        [reduce using rule 31 (EVALUATE)]
    sub        reduce using rule 22 (EXP)
    sub        [reduce using rule 31 (EVALUATE)]
    mult       reduce using rule 22 (EXP)
    mult       [reduce using rule 31 (EVALUATE)]
    divi       reduce using rule 22 (EXP)
    divi       [reduce using rule 31 (EVALUATE)]
    and        reduce using rule 31 (EVALUATE)
    or         reduce using rule 31 (EVALUATE)
    equal      reduce using rule 22 (EXP)
    equal      [reduce using rule 31 (EVALUATE)]
    neq        reduce using rule 22 (EXP)
    neq        [reduce using rule 31 (EVALUATE)]
    seq        reduce using rule 22 (EXP)
    seq        [reduce using rule 31 (EVALUATE)]
    smaller    reduce using rule 22 (EXP)
    smaller    [reduce using rule 31 (EVALUATE)]
    beq        reduce using rule 22 (EXP)
    beq        [reduce using rule 31 (EVALUATE)]
    bigger     reduce using rule 22 (EXP)
    bigger     [reduce using rule 31 (EVALUATE)]
    close_par  reduce using rule 31 (EVALUATE)
    end        reduce using rule 31 (EVALUATE)
    $default   reduce using rule 22 (EXP)


State 64

   42 DEF_FUNC: var_name TYPE open_par . ARGS close_par

    t_string  shift, and go to state 8
    t_int     shift, and go to state 9

    $default  reduce using rule 44 (ARGS)

    TYPE  go to state 70
    ARGS  go to state 71
    ARG   go to state 72


State 65

   48 FUNC: var_name TYPE . open_par ARGS close_par open_func BODY end_func

    open_par  shift, and go to state 73


State 66

   68 MAIN_FUNC: main_func . TYPE open_par ARGS close_par open_func BODY end_func

    t_string  shift, and go to state 8
    t_int     shift, and go to state 9

    TYPE  go to state 74


State 67

    1 PROGRAM: DEFINED_V GLOB_VARS DEFINED_F FUNCS MAIN_FUNC .

    $default  reduce using rule 1 (PROGRAM)


State 68

   46 FUNCS: FUNC FUNCS .

    $default  reduce using rule 46 (FUNCS)


State 69

   40 DEF_FUNCS: DEF_FUNC end DEF_FUNCS .

    $default  reduce using rule 40 (DEF_FUNCS)


State 70

   45 ARG: TYPE . var_name

    var_name  shift, and go to state 75


State 71

   42 DEF_FUNC: var_name TYPE open_par ARGS . close_par

    close_par  shift, and go to state 76


State 72

   43 ARGS: ARG . comma ARGS

    comma  shift, and go to state 77


State 73

   48 FUNC: var_name TYPE open_par . ARGS close_par open_func BODY end_func

    t_string  shift, and go to state 8
    t_int     shift, and go to state 9

    $default  reduce using rule 44 (ARGS)

    TYPE  go to state 70
    ARGS  go to state 78
    ARG   go to state 72


State 74

   68 MAIN_FUNC: main_func TYPE . open_par ARGS close_par open_func BODY end_func

    open_par  shift, and go to state 79


State 75

   45 ARG: TYPE var_name .

    $default  reduce using rule 45 (ARG)


State 76

   42 DEF_FUNC: var_name TYPE open_par ARGS close_par .

    $default  reduce using rule 42 (DEF_FUNC)


State 77

   43 ARGS: ARG comma . ARGS

    t_string  shift, and go to state 8
    t_int     shift, and go to state 9

    $default  reduce using rule 44 (ARGS)

    TYPE  go to state 70
    ARGS  go to state 80
    ARG   go to state 72


State 78

   48 FUNC: var_name TYPE open_par ARGS . close_par open_func BODY end_func

    close_par  shift, and go to state 81


State 79

   68 MAIN_FUNC: main_func TYPE open_par . ARGS close_par open_func BODY end_func

    t_string  shift, and go to state 8
    t_int     shift, and go to state 9

    $default  reduce using rule 44 (ARGS)

    TYPE  go to state 70
    ARGS  go to state 82
    ARG   go to state 72


State 80

   43 ARGS: ARG comma ARGS .

    $default  reduce using rule 43 (ARGS)


State 81

   48 FUNC: var_name TYPE open_par ARGS close_par . open_func BODY end_func

    open_func  shift, and go to state 83


State 82

   68 MAIN_FUNC: main_func TYPE open_par ARGS . close_par open_func BODY end_func

    close_par  shift, and go to state 84


State 83

   48 FUNC: var_name TYPE open_par ARGS close_par open_func . BODY end_func

    t_string    shift, and go to state 8
    t_int       shift, and go to state 9
    t_scanf     shift, and go to state 85
    t_printf    shift, and go to state 86
    open_while  shift, and go to state 87
    open_if     shift, and go to state 88
    t_ret       shift, and go to state 89
    var_name    shift, and go to state 90

    $default  reduce using rule 51 (BODY)

    DECLARE     go to state 91
    REASSIGN    go to state 92
    TYPE        go to state 16
    BODY        go to state 93
    LINE        go to state 94
    INC         go to state 95
    DEC         go to state 96
    PRINT       go to state 97
    SCAN        go to state 98
    RET         go to state 99
    BLOCK       go to state 100
    IFBLOCK     go to state 101
    WHILEBLOCK  go to state 102


State 84

   68 MAIN_FUNC: main_func TYPE open_par ARGS close_par . open_func BODY end_func

    open_func  shift, and go to state 103


State 85

   62 SCAN: t_scanf . open_par var_name close_par

    open_par  shift, and go to state 104


State 86

   61 PRINT: t_printf . open_par EXP close_par

    open_par  shift, and go to state 105


State 87

   67 WHILEBLOCK: open_while . EVALUATE end BODY close_while

    open_par    shift, and go to state 18
    int_var     shift, and go to state 19
    string_var  shift, and go to state 20
    var_name    shift, and go to state 21

    EXP       go to state 61
    OP        go to state 23
    EVALUATE  go to state 106


State 88

   66 IFBLOCK: open_if . EVALUATE end BODY close_if

    open_par    shift, and go to state 18
    int_var     shift, and go to state 19
    string_var  shift, and go to state 20
    var_name    shift, and go to state 21

    EXP       go to state 61
    OP        go to state 23
    EVALUATE  go to state 107


State 89

   63 RET: t_ret . EXP

    open_par    shift, and go to state 18
    int_var     shift, and go to state 19
    string_var  shift, and go to state 20
    var_name    shift, and go to state 21

    EXP       go to state 108
    OP        go to state 23
    EVALUATE  go to state 24


State 90

   16 REASSIGN: var_name . EXP
   59 INC: var_name . increase
   60 DEC: var_name . decrease

    increase    shift, and go to state 109
    decrease    shift, and go to state 110
    open_par    shift, and go to state 18
    int_var     shift, and go to state 19
    string_var  shift, and go to state 20
    var_name    shift, and go to state 21

    EXP       go to state 25
    OP        go to state 23
    EVALUATE  go to state 24


State 91

   53 LINE: DECLARE .

    $default  reduce using rule 53 (LINE)


State 92

   52 LINE: REASSIGN .

    $default  reduce using rule 52 (LINE)


State 93

   48 FUNC: var_name TYPE open_par ARGS close_par open_func BODY . end_func

    end_func  shift, and go to state 111


State 94

   49 BODY: LINE . end BODY

    end  shift, and go to state 112


State 95

   54 LINE: INC .

    $default  reduce using rule 54 (LINE)


State 96

   55 LINE: DEC .

    $default  reduce using rule 55 (LINE)


State 97

   56 LINE: PRINT .

    $default  reduce using rule 56 (LINE)


State 98

   57 LINE: SCAN .

    $default  reduce using rule 57 (LINE)


State 99

   58 LINE: RET .

    $default  reduce using rule 58 (LINE)


State 100

   50 BODY: BLOCK . BODY

    t_string    shift, and go to state 8
    t_int       shift, and go to state 9
    t_scanf     shift, and go to state 85
    t_printf    shift, and go to state 86
    open_while  shift, and go to state 87
    open_if     shift, and go to state 88
    t_ret       shift, and go to state 89
    var_name    shift, and go to state 90

    $default  reduce using rule 51 (BODY)

    DECLARE     go to state 91
    REASSIGN    go to state 92
    TYPE        go to state 16
    BODY        go to state 113
    LINE        go to state 94
    INC         go to state 95
    DEC         go to state 96
    PRINT       go to state 97
    SCAN        go to state 98
    RET         go to state 99
    BLOCK       go to state 100
    IFBLOCK     go to state 101
    WHILEBLOCK  go to state 102


State 101

   64 BLOCK: IFBLOCK .

    $default  reduce using rule 64 (BLOCK)


State 102

   65 BLOCK: WHILEBLOCK .

    $default  reduce using rule 65 (BLOCK)


State 103

   68 MAIN_FUNC: main_func TYPE open_par ARGS close_par open_func . BODY end_func

    t_string    shift, and go to state 8
    t_int       shift, and go to state 9
    t_scanf     shift, and go to state 85
    t_printf    shift, and go to state 86
    open_while  shift, and go to state 87
    open_if     shift, and go to state 88
    t_ret       shift, and go to state 89
    var_name    shift, and go to state 90

    $default  reduce using rule 51 (BODY)

    DECLARE     go to state 91
    REASSIGN    go to state 92
    TYPE        go to state 16
    BODY        go to state 114
    LINE        go to state 94
    INC         go to state 95
    DEC         go to state 96
    PRINT       go to state 97
    SCAN        go to state 98
    RET         go to state 99
    BLOCK       go to state 100
    IFBLOCK     go to state 101
    WHILEBLOCK  go to state 102


State 104

   62 SCAN: t_scanf open_par . var_name close_par

    var_name  shift, and go to state 115


State 105

   61 PRINT: t_printf open_par . EXP close_par

    open_par    shift, and go to state 18
    int_var     shift, and go to state 19
    string_var  shift, and go to state 20
    var_name    shift, and go to state 21

    EXP       go to state 116
    OP        go to state 23
    EVALUATE  go to state 24


State 106

   22 EXP: EVALUATE .
   30 EVALUATE: EVALUATE . and EVALUATE
   31         | EVALUATE . or EVALUATE
   67 WHILEBLOCK: open_while EVALUATE . end BODY close_while

    and  shift, and go to state 45
    or   shift, and go to state 46
    end  shift, and go to state 117

    $default  reduce using rule 22 (EXP)


State 107

   22 EXP: EVALUATE .
   30 EVALUATE: EVALUATE . and EVALUATE
   31         | EVALUATE . or EVALUATE
   66 IFBLOCK: open_if EVALUATE . end BODY close_if

    and  shift, and go to state 45
    or   shift, and go to state 46
    end  shift, and go to state 118

    $default  reduce using rule 22 (EXP)


State 108

   23 OP: EXP . add EXP
   24   | EXP . sub EXP
   25   | EXP . mult EXP
   26   | EXP . divi EXP
   29 EVALUATE: EXP . COMP EXP
   63 RET: t_ret EXP .

    add      shift, and go to state 34
    sub      shift, and go to state 35
    mult     shift, and go to state 36
    divi     shift, and go to state 37
    equal    shift, and go to state 38
    neq      shift, and go to state 39
    seq      shift, and go to state 40
    smaller  shift, and go to state 41
    beq      shift, and go to state 42
    bigger   shift, and go to state 43

    $default  reduce using rule 63 (RET)

    COMP  go to state 44


State 109

   59 INC: var_name increase .

    $default  reduce using rule 59 (INC)


State 110

   60 DEC: var_name decrease .

    $default  reduce using rule 60 (DEC)


State 111

   48 FUNC: var_name TYPE open_par ARGS close_par open_func BODY end_func .

    $default  reduce using rule 48 (FUNC)


State 112

   49 BODY: LINE end . BODY

    t_string    shift, and go to state 8
    t_int       shift, and go to state 9
    t_scanf     shift, and go to state 85
    t_printf    shift, and go to state 86
    open_while  shift, and go to state 87
    open_if     shift, and go to state 88
    t_ret       shift, and go to state 89
    var_name    shift, and go to state 90

    $default  reduce using rule 51 (BODY)

    DECLARE     go to state 91
    REASSIGN    go to state 92
    TYPE        go to state 16
    BODY        go to state 119
    LINE        go to state 94
    INC         go to state 95
    DEC         go to state 96
    PRINT       go to state 97
    SCAN        go to state 98
    RET         go to state 99
    BLOCK       go to state 100
    IFBLOCK     go to state 101
    WHILEBLOCK  go to state 102


State 113

   50 BODY: BLOCK BODY .

    $default  reduce using rule 50 (BODY)


State 114

   68 MAIN_FUNC: main_func TYPE open_par ARGS close_par open_func BODY . end_func

    end_func  shift, and go to state 120


State 115

   62 SCAN: t_scanf open_par var_name . close_par

    close_par  shift, and go to state 121


State 116

   23 OP: EXP . add EXP
   24   | EXP . sub EXP
   25   | EXP . mult EXP
   26   | EXP . divi EXP
   29 EVALUATE: EXP . COMP EXP
   61 PRINT: t_printf open_par EXP . close_par

    add        shift, and go to state 34
    sub        shift, and go to state 35
    mult       shift, and go to state 36
    divi       shift, and go to state 37
    equal      shift, and go to state 38
    neq        shift, and go to state 39
    seq        shift, and go to state 40
    smaller    shift, and go to state 41
    beq        shift, and go to state 42
    bigger     shift, and go to state 43
    close_par  shift, and go to state 122

    COMP  go to state 44


State 117

   67 WHILEBLOCK: open_while EVALUATE end . BODY close_while

    t_string    shift, and go to state 8
    t_int       shift, and go to state 9
    t_scanf     shift, and go to state 85
    t_printf    shift, and go to state 86
    open_while  shift, and go to state 87
    open_if     shift, and go to state 88
    t_ret       shift, and go to state 89
    var_name    shift, and go to state 90

    $default  reduce using rule 51 (BODY)

    DECLARE     go to state 91
    REASSIGN    go to state 92
    TYPE        go to state 16
    BODY        go to state 123
    LINE        go to state 94
    INC         go to state 95
    DEC         go to state 96
    PRINT       go to state 97
    SCAN        go to state 98
    RET         go to state 99
    BLOCK       go to state 100
    IFBLOCK     go to state 101
    WHILEBLOCK  go to state 102


State 118

   66 IFBLOCK: open_if EVALUATE end . BODY close_if

    t_string    shift, and go to state 8
    t_int       shift, and go to state 9
    t_scanf     shift, and go to state 85
    t_printf    shift, and go to state 86
    open_while  shift, and go to state 87
    open_if     shift, and go to state 88
    t_ret       shift, and go to state 89
    var_name    shift, and go to state 90

    $default  reduce using rule 51 (BODY)

    DECLARE     go to state 91
    REASSIGN    go to state 92
    TYPE        go to state 16
    BODY        go to state 124
    LINE        go to state 94
    INC         go to state 95
    DEC         go to state 96
    PRINT       go to state 97
    SCAN        go to state 98
    RET         go to state 99
    BLOCK       go to state 100
    IFBLOCK     go to state 101
    WHILEBLOCK  go to state 102


State 119

   49 BODY: LINE end BODY .

    $default  reduce using rule 49 (BODY)


State 120

   68 MAIN_FUNC: main_func TYPE open_par ARGS close_par open_func BODY end_func .

    $default  reduce using rule 68 (MAIN_FUNC)


State 121

   62 SCAN: t_scanf open_par var_name close_par .

    $default  reduce using rule 62 (SCAN)


State 122

   61 PRINT: t_printf open_par EXP close_par .

    $default  reduce using rule 61 (PRINT)


State 123

   67 WHILEBLOCK: open_while EVALUATE end BODY . close_while

    close_while  shift, and go to state 125


State 124

   66 IFBLOCK: open_if EVALUATE end BODY . close_if

    close_if  shift, and go to state 126


State 125

   67 WHILEBLOCK: open_while EVALUATE end BODY close_while .

    $default  reduce using rule 67 (WHILEBLOCK)


State 126

   66 IFBLOCK: open_if EVALUATE end BODY close_if .

    $default  reduce using rule 66 (IFBLOCK)
