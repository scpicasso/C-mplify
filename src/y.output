State 3 conflicts: 1 shift/reduce
State 10 conflicts: 1 shift/reduce
State 23 conflicts: 2 shift/reduce
State 28 conflicts: 1 shift/reduce
State 49 conflicts: 1 shift/reduce
State 58 conflicts: 10 shift/reduce
State 60 conflicts: 10 reduce/reduce
State 61 conflicts: 10 reduce/reduce


Grammar

    0 $accept: PROGRAM $end

    1 PROGRAM: DEF_VARS GLOB_VARS DEF_FUNCS FUNCS MAIN_FUNC

    2 DEF_VARS: DEF_VAR end DEF_VARS
    3         | %empty

    4 DEF_VAR: def var_name EXP

    5 GLOB_VARS: VARS

    6 VARS: VAR end VARS
    7     | %empty

    8 VAR: DECLARE
    9    | REASSIGN

   10 DECLARE: TYPE var_name ASSIGN

   11 ASSIGN: EXP
   12       | %empty

   13 REASSIGN: var_name EXP

   14 EXP: string_var
   15    | int_var
   16    | var_name
   17    | open_par EXP close_par
   18    | OP
   19    | EVALUATE

   20 OP: EXP add EXP
   21   | EXP sub EXP
   22   | EXP mult EXP
   23   | EXP divi EXP

   24 TYPE: t_string
   25     | t_int

   26 EVALUATE: EXP COMP EXP
   27         | EVALUATE and EVALUATE
   28         | EVALUATE or EVALUATE

   29 COMP: equal
   30     | neq
   31     | bigger
   32     | smaller
   33     | beq
   34     | seq

   35 DEF_FUNCS: DEF_FUNC end DEF_FUNCS
   36          | %empty

   37 DEF_FUNC: var_name TYPE open_par ARGS close_par

   38 ARGS: ARG comma ARGS
   39     | %empty

   40 ARG: TYPE var_name

   41 FUNCS: FUNC FUNCS
   42      | %empty

   43 FUNC: var_name TYPE open_par ARGS close_par open_func BODY end_func

   44 BODY: LINE end BODY
   45     | BLOCK BODY
   46     | %empty

   47 LINE: REASSIGN
   48     | DECLARE
   49     | INC
   50     | DEC
   51     | PRINT
   52     | SCAN
   53     | RET

   54 INC: var_name increase

   55 DEC: var_name decrease

   56 PRINT: t_printf open_par EXP close_par

   57 SCAN: t_scanf open_par var_name close_par

   58 RET: t_ret EXP

   59 BLOCK: IFBLOCK
   60      | WHILEBLOCK

   61 IFBLOCK: open_if EVALUATE end BODY close_if

   62 WHILEBLOCK: open_while EVALUATE end BODY close_while

   63 MAIN_FUNC: main_func TYPE open_par ARGS close_par open_func BODY end_func


Terminals, with rules where they appear

$end (0) 0
error (256)
add (258) 20
sub (259) 21
mult (260) 22
divi (261) 23
t_string (262) 24
t_int (263) 25
def (264) 4
t_scanf (265) 57
t_printf (266) 56
increase (267) 54
decrease (268) 55
open_while (269) 62
close_while (270) 62
open_if (271) 61
close_if (272) 61
and (273) 27
or (274) 28
equal (275) 29
neq (276) 30
seq (277) 34
smaller (278) 32
beq (279) 33
bigger (280) 31
main_func (281) 63
comma (282) 38
close_par (283) 17 37 43 56 57 63
open_par (284) 17 37 43 56 57 63
open_func (285) 43 63
t_ret (286) 58
end_func (287) 43 63
end (288) 2 6 35 44 61 62
int_var (289) 15
string_var (290) 14
var_name (291) 4 10 13 16 37 40 43 54 55 57


Nonterminals, with rules where they appear

$accept (37)
    on left: 0
PROGRAM (38)
    on left: 1, on right: 0
DEF_VARS (39)
    on left: 2 3, on right: 1 2
DEF_VAR (40)
    on left: 4, on right: 2
GLOB_VARS (41)
    on left: 5, on right: 1
VARS (42)
    on left: 6 7, on right: 5 6
VAR (43)
    on left: 8 9, on right: 6
DECLARE (44)
    on left: 10, on right: 8 48
ASSIGN (45)
    on left: 11 12, on right: 10
REASSIGN (46)
    on left: 13, on right: 9 47
EXP (47)
    on left: 14 15 16 17 18 19, on right: 4 11 13 17 20 21 22 23 26
    56 58
OP (48)
    on left: 20 21 22 23, on right: 18
TYPE (49)
    on left: 24 25, on right: 10 37 40 43 63
EVALUATE (50)
    on left: 26 27 28, on right: 19 27 28 61 62
COMP (51)
    on left: 29 30 31 32 33 34, on right: 26
DEF_FUNCS (52)
    on left: 35 36, on right: 1 35
DEF_FUNC (53)
    on left: 37, on right: 35
ARGS (54)
    on left: 38 39, on right: 37 38 43 63
ARG (55)
    on left: 40, on right: 38
FUNCS (56)
    on left: 41 42, on right: 1 41
FUNC (57)
    on left: 43, on right: 41
BODY (58)
    on left: 44 45 46, on right: 43 44 45 61 62 63
LINE (59)
    on left: 47 48 49 50 51 52 53, on right: 44
INC (60)
    on left: 54, on right: 49
DEC (61)
    on left: 55, on right: 50
PRINT (62)
    on left: 56, on right: 51
SCAN (63)
    on left: 57, on right: 52
RET (64)
    on left: 58, on right: 53
BLOCK (65)
    on left: 59 60, on right: 45
IFBLOCK (66)
    on left: 61, on right: 59
WHILEBLOCK (67)
    on left: 62, on right: 60
MAIN_FUNC (68)
    on left: 63, on right: 1


State 0

    0 $accept: . PROGRAM $end

    def  shift, and go to state 1

    $default  reduce using rule 3 (DEF_VARS)

    PROGRAM   go to state 2
    DEF_VARS  go to state 3
    DEF_VAR   go to state 4


State 1

    4 DEF_VAR: def . var_name EXP

    var_name  shift, and go to state 5


State 2

    0 $accept: PROGRAM . $end

    $end  shift, and go to state 6


State 3

    1 PROGRAM: DEF_VARS . GLOB_VARS DEF_FUNCS FUNCS MAIN_FUNC

    t_string  shift, and go to state 7
    t_int     shift, and go to state 8
    var_name  shift, and go to state 9

    var_name  [reduce using rule 7 (VARS)]
    $default  reduce using rule 7 (VARS)

    GLOB_VARS  go to state 10
    VARS       go to state 11
    VAR        go to state 12
    DECLARE    go to state 13
    REASSIGN   go to state 14
    TYPE       go to state 15


State 4

    2 DEF_VARS: DEF_VAR . end DEF_VARS

    end  shift, and go to state 16


State 5

    4 DEF_VAR: def var_name . EXP

    open_par    shift, and go to state 17
    int_var     shift, and go to state 18
    string_var  shift, and go to state 19
    var_name    shift, and go to state 20

    EXP       go to state 21
    OP        go to state 22
    EVALUATE  go to state 23


State 6

    0 $accept: PROGRAM $end .

    $default  accept


State 7

   24 TYPE: t_string .

    $default  reduce using rule 24 (TYPE)


State 8

   25 TYPE: t_int .

    $default  reduce using rule 25 (TYPE)


State 9

   13 REASSIGN: var_name . EXP

    open_par    shift, and go to state 17
    int_var     shift, and go to state 18
    string_var  shift, and go to state 19
    var_name    shift, and go to state 20

    EXP       go to state 24
    OP        go to state 22
    EVALUATE  go to state 23


State 10

    1 PROGRAM: DEF_VARS GLOB_VARS . DEF_FUNCS FUNCS MAIN_FUNC

    var_name  shift, and go to state 25

    var_name  [reduce using rule 36 (DEF_FUNCS)]
    $default  reduce using rule 36 (DEF_FUNCS)

    DEF_FUNCS  go to state 26
    DEF_FUNC   go to state 27


State 11

    5 GLOB_VARS: VARS .

    $default  reduce using rule 5 (GLOB_VARS)


State 12

    6 VARS: VAR . end VARS

    end  shift, and go to state 28


State 13

    8 VAR: DECLARE .

    $default  reduce using rule 8 (VAR)


State 14

    9 VAR: REASSIGN .

    $default  reduce using rule 9 (VAR)


State 15

   10 DECLARE: TYPE . var_name ASSIGN

    var_name  shift, and go to state 29


State 16

    2 DEF_VARS: DEF_VAR end . DEF_VARS

    def  shift, and go to state 1

    $default  reduce using rule 3 (DEF_VARS)

    DEF_VARS  go to state 30
    DEF_VAR   go to state 4


State 17

   17 EXP: open_par . EXP close_par

    open_par    shift, and go to state 17
    int_var     shift, and go to state 18
    string_var  shift, and go to state 19
    var_name    shift, and go to state 20

    EXP       go to state 31
    OP        go to state 22
    EVALUATE  go to state 23


State 18

   15 EXP: int_var .

    $default  reduce using rule 15 (EXP)


State 19

   14 EXP: string_var .

    $default  reduce using rule 14 (EXP)


State 20

   16 EXP: var_name .

    $default  reduce using rule 16 (EXP)


State 21

    4 DEF_VAR: def var_name EXP .
   20 OP: EXP . add EXP
   21   | EXP . sub EXP
   22   | EXP . mult EXP
   23   | EXP . divi EXP
   26 EVALUATE: EXP . COMP EXP

    add      shift, and go to state 32
    sub      shift, and go to state 33
    mult     shift, and go to state 34
    divi     shift, and go to state 35
    equal    shift, and go to state 36
    neq      shift, and go to state 37
    seq      shift, and go to state 38
    smaller  shift, and go to state 39
    beq      shift, and go to state 40
    bigger   shift, and go to state 41

    $default  reduce using rule 4 (DEF_VAR)

    COMP  go to state 42


State 22

   18 EXP: OP .

    $default  reduce using rule 18 (EXP)


State 23

   19 EXP: EVALUATE .
   27 EVALUATE: EVALUATE . and EVALUATE
   28         | EVALUATE . or EVALUATE

    and  shift, and go to state 43
    or   shift, and go to state 44

    and       [reduce using rule 19 (EXP)]
    or        [reduce using rule 19 (EXP)]
    $default  reduce using rule 19 (EXP)


State 24

   13 REASSIGN: var_name EXP .
   20 OP: EXP . add EXP
   21   | EXP . sub EXP
   22   | EXP . mult EXP
   23   | EXP . divi EXP
   26 EVALUATE: EXP . COMP EXP

    add      shift, and go to state 32
    sub      shift, and go to state 33
    mult     shift, and go to state 34
    divi     shift, and go to state 35
    equal    shift, and go to state 36
    neq      shift, and go to state 37
    seq      shift, and go to state 38
    smaller  shift, and go to state 39
    beq      shift, and go to state 40
    bigger   shift, and go to state 41

    $default  reduce using rule 13 (REASSIGN)

    COMP  go to state 42


State 25

   37 DEF_FUNC: var_name . TYPE open_par ARGS close_par

    t_string  shift, and go to state 7
    t_int     shift, and go to state 8

    TYPE  go to state 45


State 26

    1 PROGRAM: DEF_VARS GLOB_VARS DEF_FUNCS . FUNCS MAIN_FUNC

    var_name  shift, and go to state 46

    $default  reduce using rule 42 (FUNCS)

    FUNCS  go to state 47
    FUNC   go to state 48


State 27

   35 DEF_FUNCS: DEF_FUNC . end DEF_FUNCS

    end  shift, and go to state 49


State 28

    6 VARS: VAR end . VARS

    t_string  shift, and go to state 7
    t_int     shift, and go to state 8
    var_name  shift, and go to state 9

    var_name  [reduce using rule 7 (VARS)]
    $default  reduce using rule 7 (VARS)

    VARS      go to state 50
    VAR       go to state 12
    DECLARE   go to state 13
    REASSIGN  go to state 14
    TYPE      go to state 15


State 29

   10 DECLARE: TYPE var_name . ASSIGN

    open_par    shift, and go to state 17
    int_var     shift, and go to state 18
    string_var  shift, and go to state 19
    var_name    shift, and go to state 20

    $default  reduce using rule 12 (ASSIGN)

    ASSIGN    go to state 51
    EXP       go to state 52
    OP        go to state 22
    EVALUATE  go to state 23


State 30

    2 DEF_VARS: DEF_VAR end DEF_VARS .

    $default  reduce using rule 2 (DEF_VARS)


State 31

   17 EXP: open_par EXP . close_par
   20 OP: EXP . add EXP
   21   | EXP . sub EXP
   22   | EXP . mult EXP
   23   | EXP . divi EXP
   26 EVALUATE: EXP . COMP EXP

    add        shift, and go to state 32
    sub        shift, and go to state 33
    mult       shift, and go to state 34
    divi       shift, and go to state 35
    equal      shift, and go to state 36
    neq        shift, and go to state 37
    seq        shift, and go to state 38
    smaller    shift, and go to state 39
    beq        shift, and go to state 40
    bigger     shift, and go to state 41
    close_par  shift, and go to state 53

    COMP  go to state 42


State 32

   20 OP: EXP add . EXP

    open_par    shift, and go to state 17
    int_var     shift, and go to state 18
    string_var  shift, and go to state 19
    var_name    shift, and go to state 20

    EXP       go to state 54
    OP        go to state 22
    EVALUATE  go to state 23


State 33

   21 OP: EXP sub . EXP

    open_par    shift, and go to state 17
    int_var     shift, and go to state 18
    string_var  shift, and go to state 19
    var_name    shift, and go to state 20

    EXP       go to state 55
    OP        go to state 22
    EVALUATE  go to state 23


State 34

   22 OP: EXP mult . EXP

    open_par    shift, and go to state 17
    int_var     shift, and go to state 18
    string_var  shift, and go to state 19
    var_name    shift, and go to state 20

    EXP       go to state 56
    OP        go to state 22
    EVALUATE  go to state 23


State 35

   23 OP: EXP divi . EXP

    open_par    shift, and go to state 17
    int_var     shift, and go to state 18
    string_var  shift, and go to state 19
    var_name    shift, and go to state 20

    EXP       go to state 57
    OP        go to state 22
    EVALUATE  go to state 23


State 36

   29 COMP: equal .

    $default  reduce using rule 29 (COMP)


State 37

   30 COMP: neq .

    $default  reduce using rule 30 (COMP)


State 38

   34 COMP: seq .

    $default  reduce using rule 34 (COMP)


State 39

   32 COMP: smaller .

    $default  reduce using rule 32 (COMP)


State 40

   33 COMP: beq .

    $default  reduce using rule 33 (COMP)


State 41

   31 COMP: bigger .

    $default  reduce using rule 31 (COMP)


State 42

   26 EVALUATE: EXP COMP . EXP

    open_par    shift, and go to state 17
    int_var     shift, and go to state 18
    string_var  shift, and go to state 19
    var_name    shift, and go to state 20

    EXP       go to state 58
    OP        go to state 22
    EVALUATE  go to state 23


State 43

   27 EVALUATE: EVALUATE and . EVALUATE

    open_par    shift, and go to state 17
    int_var     shift, and go to state 18
    string_var  shift, and go to state 19
    var_name    shift, and go to state 20

    EXP       go to state 59
    OP        go to state 22
    EVALUATE  go to state 60


State 44

   28 EVALUATE: EVALUATE or . EVALUATE

    open_par    shift, and go to state 17
    int_var     shift, and go to state 18
    string_var  shift, and go to state 19
    var_name    shift, and go to state 20

    EXP       go to state 59
    OP        go to state 22
    EVALUATE  go to state 61


State 45

   37 DEF_FUNC: var_name TYPE . open_par ARGS close_par

    open_par  shift, and go to state 62


State 46

   43 FUNC: var_name . TYPE open_par ARGS close_par open_func BODY end_func

    t_string  shift, and go to state 7
    t_int     shift, and go to state 8

    TYPE  go to state 63


State 47

    1 PROGRAM: DEF_VARS GLOB_VARS DEF_FUNCS FUNCS . MAIN_FUNC

    main_func  shift, and go to state 64

    MAIN_FUNC  go to state 65


State 48

   41 FUNCS: FUNC . FUNCS

    var_name  shift, and go to state 46

    $default  reduce using rule 42 (FUNCS)

    FUNCS  go to state 66
    FUNC   go to state 48


State 49

   35 DEF_FUNCS: DEF_FUNC end . DEF_FUNCS

    var_name  shift, and go to state 25

    var_name  [reduce using rule 36 (DEF_FUNCS)]
    $default  reduce using rule 36 (DEF_FUNCS)

    DEF_FUNCS  go to state 67
    DEF_FUNC   go to state 27


State 50

    6 VARS: VAR end VARS .

    $default  reduce using rule 6 (VARS)


State 51

   10 DECLARE: TYPE var_name ASSIGN .

    $default  reduce using rule 10 (DECLARE)


State 52

   11 ASSIGN: EXP .
   20 OP: EXP . add EXP
   21   | EXP . sub EXP
   22   | EXP . mult EXP
   23   | EXP . divi EXP
   26 EVALUATE: EXP . COMP EXP

    add      shift, and go to state 32
    sub      shift, and go to state 33
    mult     shift, and go to state 34
    divi     shift, and go to state 35
    equal    shift, and go to state 36
    neq      shift, and go to state 37
    seq      shift, and go to state 38
    smaller  shift, and go to state 39
    beq      shift, and go to state 40
    bigger   shift, and go to state 41

    $default  reduce using rule 11 (ASSIGN)

    COMP  go to state 42


State 53

   17 EXP: open_par EXP close_par .

    $default  reduce using rule 17 (EXP)


State 54

   20 OP: EXP . add EXP
   20   | EXP add EXP .
   21   | EXP . sub EXP
   22   | EXP . mult EXP
   23   | EXP . divi EXP
   26 EVALUATE: EXP . COMP EXP

    mult     shift, and go to state 34
    divi     shift, and go to state 35
    equal    shift, and go to state 36
    neq      shift, and go to state 37
    seq      shift, and go to state 38
    smaller  shift, and go to state 39
    beq      shift, and go to state 40
    bigger   shift, and go to state 41

    $default  reduce using rule 20 (OP)

    COMP  go to state 42


State 55

   20 OP: EXP . add EXP
   21   | EXP . sub EXP
   21   | EXP sub EXP .
   22   | EXP . mult EXP
   23   | EXP . divi EXP
   26 EVALUATE: EXP . COMP EXP

    mult     shift, and go to state 34
    divi     shift, and go to state 35
    equal    shift, and go to state 36
    neq      shift, and go to state 37
    seq      shift, and go to state 38
    smaller  shift, and go to state 39
    beq      shift, and go to state 40
    bigger   shift, and go to state 41

    $default  reduce using rule 21 (OP)

    COMP  go to state 42


State 56

   20 OP: EXP . add EXP
   21   | EXP . sub EXP
   22   | EXP . mult EXP
   22   | EXP mult EXP .
   23   | EXP . divi EXP
   26 EVALUATE: EXP . COMP EXP

    equal    shift, and go to state 36
    neq      shift, and go to state 37
    seq      shift, and go to state 38
    smaller  shift, and go to state 39
    beq      shift, and go to state 40
    bigger   shift, and go to state 41

    $default  reduce using rule 22 (OP)

    COMP  go to state 42


State 57

   20 OP: EXP . add EXP
   21   | EXP . sub EXP
   22   | EXP . mult EXP
   23   | EXP . divi EXP
   23   | EXP divi EXP .
   26 EVALUATE: EXP . COMP EXP

    equal    shift, and go to state 36
    neq      shift, and go to state 37
    seq      shift, and go to state 38
    smaller  shift, and go to state 39
    beq      shift, and go to state 40
    bigger   shift, and go to state 41

    $default  reduce using rule 23 (OP)

    COMP  go to state 42


State 58

   20 OP: EXP . add EXP
   21   | EXP . sub EXP
   22   | EXP . mult EXP
   23   | EXP . divi EXP
   26 EVALUATE: EXP . COMP EXP
   26         | EXP COMP EXP .

    add      shift, and go to state 32
    sub      shift, and go to state 33
    mult     shift, and go to state 34
    divi     shift, and go to state 35
    equal    shift, and go to state 36
    neq      shift, and go to state 37
    seq      shift, and go to state 38
    smaller  shift, and go to state 39
    beq      shift, and go to state 40
    bigger   shift, and go to state 41

    add       [reduce using rule 26 (EVALUATE)]
    sub       [reduce using rule 26 (EVALUATE)]
    mult      [reduce using rule 26 (EVALUATE)]
    divi      [reduce using rule 26 (EVALUATE)]
    equal     [reduce using rule 26 (EVALUATE)]
    neq       [reduce using rule 26 (EVALUATE)]
    seq       [reduce using rule 26 (EVALUATE)]
    smaller   [reduce using rule 26 (EVALUATE)]
    beq       [reduce using rule 26 (EVALUATE)]
    bigger    [reduce using rule 26 (EVALUATE)]
    $default  reduce using rule 26 (EVALUATE)

    COMP  go to state 42


State 59

   20 OP: EXP . add EXP
   21   | EXP . sub EXP
   22   | EXP . mult EXP
   23   | EXP . divi EXP
   26 EVALUATE: EXP . COMP EXP

    add      shift, and go to state 32
    sub      shift, and go to state 33
    mult     shift, and go to state 34
    divi     shift, and go to state 35
    equal    shift, and go to state 36
    neq      shift, and go to state 37
    seq      shift, and go to state 38
    smaller  shift, and go to state 39
    beq      shift, and go to state 40
    bigger   shift, and go to state 41

    COMP  go to state 42


State 60

   19 EXP: EVALUATE .
   27 EVALUATE: EVALUATE . and EVALUATE
   27         | EVALUATE and EVALUATE .
   28         | EVALUATE . or EVALUATE

    or  shift, and go to state 44

    add        reduce using rule 19 (EXP)
    add        [reduce using rule 27 (EVALUATE)]
    sub        reduce using rule 19 (EXP)
    sub        [reduce using rule 27 (EVALUATE)]
    mult       reduce using rule 19 (EXP)
    mult       [reduce using rule 27 (EVALUATE)]
    divi       reduce using rule 19 (EXP)
    divi       [reduce using rule 27 (EVALUATE)]
    and        reduce using rule 27 (EVALUATE)
    equal      reduce using rule 19 (EXP)
    equal      [reduce using rule 27 (EVALUATE)]
    neq        reduce using rule 19 (EXP)
    neq        [reduce using rule 27 (EVALUATE)]
    seq        reduce using rule 19 (EXP)
    seq        [reduce using rule 27 (EVALUATE)]
    smaller    reduce using rule 19 (EXP)
    smaller    [reduce using rule 27 (EVALUATE)]
    beq        reduce using rule 19 (EXP)
    beq        [reduce using rule 27 (EVALUATE)]
    bigger     reduce using rule 19 (EXP)
    bigger     [reduce using rule 27 (EVALUATE)]
    close_par  reduce using rule 27 (EVALUATE)
    end        reduce using rule 27 (EVALUATE)
    $default   reduce using rule 19 (EXP)


State 61

   19 EXP: EVALUATE .
   27 EVALUATE: EVALUATE . and EVALUATE
   28         | EVALUATE . or EVALUATE
   28         | EVALUATE or EVALUATE .

    add        reduce using rule 19 (EXP)
    add        [reduce using rule 28 (EVALUATE)]
    sub        reduce using rule 19 (EXP)
    sub        [reduce using rule 28 (EVALUATE)]
    mult       reduce using rule 19 (EXP)
    mult       [reduce using rule 28 (EVALUATE)]
    divi       reduce using rule 19 (EXP)
    divi       [reduce using rule 28 (EVALUATE)]
    and        reduce using rule 28 (EVALUATE)
    or         reduce using rule 28 (EVALUATE)
    equal      reduce using rule 19 (EXP)
    equal      [reduce using rule 28 (EVALUATE)]
    neq        reduce using rule 19 (EXP)
    neq        [reduce using rule 28 (EVALUATE)]
    seq        reduce using rule 19 (EXP)
    seq        [reduce using rule 28 (EVALUATE)]
    smaller    reduce using rule 19 (EXP)
    smaller    [reduce using rule 28 (EVALUATE)]
    beq        reduce using rule 19 (EXP)
    beq        [reduce using rule 28 (EVALUATE)]
    bigger     reduce using rule 19 (EXP)
    bigger     [reduce using rule 28 (EVALUATE)]
    close_par  reduce using rule 28 (EVALUATE)
    end        reduce using rule 28 (EVALUATE)
    $default   reduce using rule 19 (EXP)


State 62

   37 DEF_FUNC: var_name TYPE open_par . ARGS close_par

    t_string  shift, and go to state 7
    t_int     shift, and go to state 8

    $default  reduce using rule 39 (ARGS)

    TYPE  go to state 68
    ARGS  go to state 69
    ARG   go to state 70


State 63

   43 FUNC: var_name TYPE . open_par ARGS close_par open_func BODY end_func

    open_par  shift, and go to state 71


State 64

   63 MAIN_FUNC: main_func . TYPE open_par ARGS close_par open_func BODY end_func

    t_string  shift, and go to state 7
    t_int     shift, and go to state 8

    TYPE  go to state 72


State 65

    1 PROGRAM: DEF_VARS GLOB_VARS DEF_FUNCS FUNCS MAIN_FUNC .

    $default  reduce using rule 1 (PROGRAM)


State 66

   41 FUNCS: FUNC FUNCS .

    $default  reduce using rule 41 (FUNCS)


State 67

   35 DEF_FUNCS: DEF_FUNC end DEF_FUNCS .

    $default  reduce using rule 35 (DEF_FUNCS)


State 68

   40 ARG: TYPE . var_name

    var_name  shift, and go to state 73


State 69

   37 DEF_FUNC: var_name TYPE open_par ARGS . close_par

    close_par  shift, and go to state 74


State 70

   38 ARGS: ARG . comma ARGS

    comma  shift, and go to state 75


State 71

   43 FUNC: var_name TYPE open_par . ARGS close_par open_func BODY end_func

    t_string  shift, and go to state 7
    t_int     shift, and go to state 8

    $default  reduce using rule 39 (ARGS)

    TYPE  go to state 68
    ARGS  go to state 76
    ARG   go to state 70


State 72

   63 MAIN_FUNC: main_func TYPE . open_par ARGS close_par open_func BODY end_func

    open_par  shift, and go to state 77


State 73

   40 ARG: TYPE var_name .

    $default  reduce using rule 40 (ARG)


State 74

   37 DEF_FUNC: var_name TYPE open_par ARGS close_par .

    $default  reduce using rule 37 (DEF_FUNC)


State 75

   38 ARGS: ARG comma . ARGS

    t_string  shift, and go to state 7
    t_int     shift, and go to state 8

    $default  reduce using rule 39 (ARGS)

    TYPE  go to state 68
    ARGS  go to state 78
    ARG   go to state 70


State 76

   43 FUNC: var_name TYPE open_par ARGS . close_par open_func BODY end_func

    close_par  shift, and go to state 79


State 77

   63 MAIN_FUNC: main_func TYPE open_par . ARGS close_par open_func BODY end_func

    t_string  shift, and go to state 7
    t_int     shift, and go to state 8

    $default  reduce using rule 39 (ARGS)

    TYPE  go to state 68
    ARGS  go to state 80
    ARG   go to state 70


State 78

   38 ARGS: ARG comma ARGS .

    $default  reduce using rule 38 (ARGS)


State 79

   43 FUNC: var_name TYPE open_par ARGS close_par . open_func BODY end_func

    open_func  shift, and go to state 81


State 80

   63 MAIN_FUNC: main_func TYPE open_par ARGS . close_par open_func BODY end_func

    close_par  shift, and go to state 82


State 81

   43 FUNC: var_name TYPE open_par ARGS close_par open_func . BODY end_func

    t_string    shift, and go to state 7
    t_int       shift, and go to state 8
    t_scanf     shift, and go to state 83
    t_printf    shift, and go to state 84
    open_while  shift, and go to state 85
    open_if     shift, and go to state 86
    t_ret       shift, and go to state 87
    var_name    shift, and go to state 88

    $default  reduce using rule 46 (BODY)

    DECLARE     go to state 89
    REASSIGN    go to state 90
    TYPE        go to state 15
    BODY        go to state 91
    LINE        go to state 92
    INC         go to state 93
    DEC         go to state 94
    PRINT       go to state 95
    SCAN        go to state 96
    RET         go to state 97
    BLOCK       go to state 98
    IFBLOCK     go to state 99
    WHILEBLOCK  go to state 100


State 82

   63 MAIN_FUNC: main_func TYPE open_par ARGS close_par . open_func BODY end_func

    open_func  shift, and go to state 101


State 83

   57 SCAN: t_scanf . open_par var_name close_par

    open_par  shift, and go to state 102


State 84

   56 PRINT: t_printf . open_par EXP close_par

    open_par  shift, and go to state 103


State 85

   62 WHILEBLOCK: open_while . EVALUATE end BODY close_while

    open_par    shift, and go to state 17
    int_var     shift, and go to state 18
    string_var  shift, and go to state 19
    var_name    shift, and go to state 20

    EXP       go to state 59
    OP        go to state 22
    EVALUATE  go to state 104


State 86

   61 IFBLOCK: open_if . EVALUATE end BODY close_if

    open_par    shift, and go to state 17
    int_var     shift, and go to state 18
    string_var  shift, and go to state 19
    var_name    shift, and go to state 20

    EXP       go to state 59
    OP        go to state 22
    EVALUATE  go to state 105


State 87

   58 RET: t_ret . EXP

    open_par    shift, and go to state 17
    int_var     shift, and go to state 18
    string_var  shift, and go to state 19
    var_name    shift, and go to state 20

    EXP       go to state 106
    OP        go to state 22
    EVALUATE  go to state 23


State 88

   13 REASSIGN: var_name . EXP
   54 INC: var_name . increase
   55 DEC: var_name . decrease

    increase    shift, and go to state 107
    decrease    shift, and go to state 108
    open_par    shift, and go to state 17
    int_var     shift, and go to state 18
    string_var  shift, and go to state 19
    var_name    shift, and go to state 20

    EXP       go to state 24
    OP        go to state 22
    EVALUATE  go to state 23


State 89

   48 LINE: DECLARE .

    $default  reduce using rule 48 (LINE)


State 90

   47 LINE: REASSIGN .

    $default  reduce using rule 47 (LINE)


State 91

   43 FUNC: var_name TYPE open_par ARGS close_par open_func BODY . end_func

    end_func  shift, and go to state 109


State 92

   44 BODY: LINE . end BODY

    end  shift, and go to state 110


State 93

   49 LINE: INC .

    $default  reduce using rule 49 (LINE)


State 94

   50 LINE: DEC .

    $default  reduce using rule 50 (LINE)


State 95

   51 LINE: PRINT .

    $default  reduce using rule 51 (LINE)


State 96

   52 LINE: SCAN .

    $default  reduce using rule 52 (LINE)


State 97

   53 LINE: RET .

    $default  reduce using rule 53 (LINE)


State 98

   45 BODY: BLOCK . BODY

    t_string    shift, and go to state 7
    t_int       shift, and go to state 8
    t_scanf     shift, and go to state 83
    t_printf    shift, and go to state 84
    open_while  shift, and go to state 85
    open_if     shift, and go to state 86
    t_ret       shift, and go to state 87
    var_name    shift, and go to state 88

    $default  reduce using rule 46 (BODY)

    DECLARE     go to state 89
    REASSIGN    go to state 90
    TYPE        go to state 15
    BODY        go to state 111
    LINE        go to state 92
    INC         go to state 93
    DEC         go to state 94
    PRINT       go to state 95
    SCAN        go to state 96
    RET         go to state 97
    BLOCK       go to state 98
    IFBLOCK     go to state 99
    WHILEBLOCK  go to state 100


State 99

   59 BLOCK: IFBLOCK .

    $default  reduce using rule 59 (BLOCK)


State 100

   60 BLOCK: WHILEBLOCK .

    $default  reduce using rule 60 (BLOCK)


State 101

   63 MAIN_FUNC: main_func TYPE open_par ARGS close_par open_func . BODY end_func

    t_string    shift, and go to state 7
    t_int       shift, and go to state 8
    t_scanf     shift, and go to state 83
    t_printf    shift, and go to state 84
    open_while  shift, and go to state 85
    open_if     shift, and go to state 86
    t_ret       shift, and go to state 87
    var_name    shift, and go to state 88

    $default  reduce using rule 46 (BODY)

    DECLARE     go to state 89
    REASSIGN    go to state 90
    TYPE        go to state 15
    BODY        go to state 112
    LINE        go to state 92
    INC         go to state 93
    DEC         go to state 94
    PRINT       go to state 95
    SCAN        go to state 96
    RET         go to state 97
    BLOCK       go to state 98
    IFBLOCK     go to state 99
    WHILEBLOCK  go to state 100


State 102

   57 SCAN: t_scanf open_par . var_name close_par

    var_name  shift, and go to state 113


State 103

   56 PRINT: t_printf open_par . EXP close_par

    open_par    shift, and go to state 17
    int_var     shift, and go to state 18
    string_var  shift, and go to state 19
    var_name    shift, and go to state 20

    EXP       go to state 114
    OP        go to state 22
    EVALUATE  go to state 23


State 104

   19 EXP: EVALUATE .
   27 EVALUATE: EVALUATE . and EVALUATE
   28         | EVALUATE . or EVALUATE
   62 WHILEBLOCK: open_while EVALUATE . end BODY close_while

    and  shift, and go to state 43
    or   shift, and go to state 44
    end  shift, and go to state 115

    $default  reduce using rule 19 (EXP)


State 105

   19 EXP: EVALUATE .
   27 EVALUATE: EVALUATE . and EVALUATE
   28         | EVALUATE . or EVALUATE
   61 IFBLOCK: open_if EVALUATE . end BODY close_if

    and  shift, and go to state 43
    or   shift, and go to state 44
    end  shift, and go to state 116

    $default  reduce using rule 19 (EXP)


State 106

   20 OP: EXP . add EXP
   21   | EXP . sub EXP
   22   | EXP . mult EXP
   23   | EXP . divi EXP
   26 EVALUATE: EXP . COMP EXP
   58 RET: t_ret EXP .

    add      shift, and go to state 32
    sub      shift, and go to state 33
    mult     shift, and go to state 34
    divi     shift, and go to state 35
    equal    shift, and go to state 36
    neq      shift, and go to state 37
    seq      shift, and go to state 38
    smaller  shift, and go to state 39
    beq      shift, and go to state 40
    bigger   shift, and go to state 41

    $default  reduce using rule 58 (RET)

    COMP  go to state 42


State 107

   54 INC: var_name increase .

    $default  reduce using rule 54 (INC)


State 108

   55 DEC: var_name decrease .

    $default  reduce using rule 55 (DEC)


State 109

   43 FUNC: var_name TYPE open_par ARGS close_par open_func BODY end_func .

    $default  reduce using rule 43 (FUNC)


State 110

   44 BODY: LINE end . BODY

    t_string    shift, and go to state 7
    t_int       shift, and go to state 8
    t_scanf     shift, and go to state 83
    t_printf    shift, and go to state 84
    open_while  shift, and go to state 85
    open_if     shift, and go to state 86
    t_ret       shift, and go to state 87
    var_name    shift, and go to state 88

    $default  reduce using rule 46 (BODY)

    DECLARE     go to state 89
    REASSIGN    go to state 90
    TYPE        go to state 15
    BODY        go to state 117
    LINE        go to state 92
    INC         go to state 93
    DEC         go to state 94
    PRINT       go to state 95
    SCAN        go to state 96
    RET         go to state 97
    BLOCK       go to state 98
    IFBLOCK     go to state 99
    WHILEBLOCK  go to state 100


State 111

   45 BODY: BLOCK BODY .

    $default  reduce using rule 45 (BODY)


State 112

   63 MAIN_FUNC: main_func TYPE open_par ARGS close_par open_func BODY . end_func

    end_func  shift, and go to state 118


State 113

   57 SCAN: t_scanf open_par var_name . close_par

    close_par  shift, and go to state 119


State 114

   20 OP: EXP . add EXP
   21   | EXP . sub EXP
   22   | EXP . mult EXP
   23   | EXP . divi EXP
   26 EVALUATE: EXP . COMP EXP
   56 PRINT: t_printf open_par EXP . close_par

    add        shift, and go to state 32
    sub        shift, and go to state 33
    mult       shift, and go to state 34
    divi       shift, and go to state 35
    equal      shift, and go to state 36
    neq        shift, and go to state 37
    seq        shift, and go to state 38
    smaller    shift, and go to state 39
    beq        shift, and go to state 40
    bigger     shift, and go to state 41
    close_par  shift, and go to state 120

    COMP  go to state 42


State 115

   62 WHILEBLOCK: open_while EVALUATE end . BODY close_while

    t_string    shift, and go to state 7
    t_int       shift, and go to state 8
    t_scanf     shift, and go to state 83
    t_printf    shift, and go to state 84
    open_while  shift, and go to state 85
    open_if     shift, and go to state 86
    t_ret       shift, and go to state 87
    var_name    shift, and go to state 88

    $default  reduce using rule 46 (BODY)

    DECLARE     go to state 89
    REASSIGN    go to state 90
    TYPE        go to state 15
    BODY        go to state 121
    LINE        go to state 92
    INC         go to state 93
    DEC         go to state 94
    PRINT       go to state 95
    SCAN        go to state 96
    RET         go to state 97
    BLOCK       go to state 98
    IFBLOCK     go to state 99
    WHILEBLOCK  go to state 100


State 116

   61 IFBLOCK: open_if EVALUATE end . BODY close_if

    t_string    shift, and go to state 7
    t_int       shift, and go to state 8
    t_scanf     shift, and go to state 83
    t_printf    shift, and go to state 84
    open_while  shift, and go to state 85
    open_if     shift, and go to state 86
    t_ret       shift, and go to state 87
    var_name    shift, and go to state 88

    $default  reduce using rule 46 (BODY)

    DECLARE     go to state 89
    REASSIGN    go to state 90
    TYPE        go to state 15
    BODY        go to state 122
    LINE        go to state 92
    INC         go to state 93
    DEC         go to state 94
    PRINT       go to state 95
    SCAN        go to state 96
    RET         go to state 97
    BLOCK       go to state 98
    IFBLOCK     go to state 99
    WHILEBLOCK  go to state 100


State 117

   44 BODY: LINE end BODY .

    $default  reduce using rule 44 (BODY)


State 118

   63 MAIN_FUNC: main_func TYPE open_par ARGS close_par open_func BODY end_func .

    $default  reduce using rule 63 (MAIN_FUNC)


State 119

   57 SCAN: t_scanf open_par var_name close_par .

    $default  reduce using rule 57 (SCAN)


State 120

   56 PRINT: t_printf open_par EXP close_par .

    $default  reduce using rule 56 (PRINT)


State 121

   62 WHILEBLOCK: open_while EVALUATE end BODY . close_while

    close_while  shift, and go to state 123


State 122

   61 IFBLOCK: open_if EVALUATE end BODY . close_if

    close_if  shift, and go to state 124


State 123

   62 WHILEBLOCK: open_while EVALUATE end BODY close_while .

    $default  reduce using rule 62 (WHILEBLOCK)


State 124

   61 IFBLOCK: open_if EVALUATE end BODY close_if .

    $default  reduce using rule 61 (IFBLOCK)
